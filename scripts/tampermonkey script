// ==UserScript==
// @name         CP Toolkit - Remote Loader (with OnLoad Scripts Manager)
// @namespace    http://civicplus.com/
// @version      1.4.11
// @description  Loader for CivicPlus admin helpers (minimal logging). Injects on-load helpers immediately and supports SPA navigation.
// @match        *://*/*
// @grant        none
// @run-at       document-end
// ==/UserScript==

(function () {
  'use strict';

  const TOOL_NAME = '[CP Toolkit Loader]';
  const STORAGE_KEY = 'cptoolkit.enabledScripts.v1';

    // ======= Script registry: add your helpers here =======
  const scriptRegistry = [
    // 1) Graphic link helpers: run first on the Graphic Links admin page. These helpers
    // run only on `/admin/graphiclinks*` and will be skipped on other pages.
    { id: 'graphic_link_helper', name: 'Graphic Link Helper', url: 'https://raw.githubusercontent.com/CodyGantCivic/toolkit-data/main/scripts/on-load/GraphicLinkHelper.js', pages: ['/admin/graphiclinks*'] },
    { id: 'graphic_link_autofill', name: 'Graphic Link Autofill', url: 'https://raw.githubusercontent.com/CodyGantCivic/toolkit-data/main/scripts/on-load/graphiclinkautofill.js', pages: ['/admin/graphiclinks.aspx*'] },

    // 2) Widget/theme helpers: prioritize these on Design Center theme pages before module icons
    // so they initialize styling and enhancements early on theme pages.
    { id: 'advanced_styles', name: 'Advanced Styles Helper', url: 'https://raw.githubusercontent.com/CodyGantCivic/toolkit-data/main/scripts/on-load/AdvancedStylesHelper.js', pages: ['/designcenter/themes*','/designcenter/widgets*'] },
    { id: 'widget_skin', name: 'Widget Skin Helper', url: 'https://raw.githubusercontent.com/CodyGantCivic/toolkit-data/main/scripts/on-load/widgetSkinHelper.js', pages: ['/designcenter/themes*'] },
    { id: 'theme_manager_enhancer', name: 'Theme Manager Enhancer', url: 'https://raw.githubusercontent.com/CodyGantCivic/toolkit-data/main/scripts/on-load/ThemeManagerEnhancer.js', pages: ['/designcenter/themes*','/designcenter/widgets*','/designcenter/animations*'] },
    { id: 'widget_skin_default_override', name: 'Widget Skin Default Override', url: 'https://raw.githubusercontent.com/CodyGantCivic/toolkit-data/main/scripts/on-load/widget-skin-default-override.js', pages: ['/designcenter/themes*'] },

    // 3) Module icons helper: adds FontAwesome icons to favorite modules on all CivicPlus pages
    { id: 'module_icons', name: 'Module Icons', url: 'https://raw.githubusercontent.com/CodyGantCivic/toolkit-data/main/scripts/on-load/moduleIcons.js', pages: ['*'] },

    // 4) Other helpers for specific pages
    { id: 'download_xml_css', name: 'Download XML/CSS', url: 'https://raw.githubusercontent.com/CodyGantCivic/toolkit-data/main/scripts/on-load/DownloadXMLCSS.js', pages: ['/admin/designcenter/layouts'] },
    { id: 'xml_major_change_alert', name: 'XML Major Change Alert', url: 'https://raw.githubusercontent.com/CodyGantCivic/toolkit-data/main/scripts/on-load/XMLMajorChangeAlert.js', pages: ['/admin/designcenter/layouts/modify*'] },
    { id: 'allow_open_in_new_tab', name: 'Allow Open In New Tab', url: 'https://raw.githubusercontent.com/CodyGantCivic/toolkit-data/main/scripts/on-load/AllowOpenInNewTab.js', pages: ['/admin*'] },
    { id: 'multiple_quick_links', name: 'Multiple Quick Links', url: 'https://raw.githubusercontent.com/CodyGantCivic/toolkit-data/main/scripts/on-load/cp-MultipleQuickLinks.js', pages: ['/admin/quicklinks.aspx*'] },
    { id: 'multiple_category_upload', name: 'Multiple Category Upload', url: 'https://raw.githubusercontent.com/CodyGantCivic/toolkit-data/main/scripts/on-load/cp-MultipleCategoryUpload.js', pages: ['/admin/infoii.aspx*','/admin/graphiclinks.aspx*','/admin/quicklinks.aspx*'] },
    { id: 'multiple_item_upload', name: 'Multiple Item Upload', url: 'https://raw.githubusercontent.com/CodyGantCivic/toolkit-data/main/scripts/on-load/cp-MultipleItemUpload.js', pages: ['/admin/civicalerts.aspx*'] },
    { id: 'input_focus', name: 'Input Focus', url: 'https://raw.githubusercontent.com/CodyGantCivic/toolkit-data/main/scripts/on-load/input-focus.js', pages: ['/admin*'] },
    { id: 'keyboard_shortcuts', name: 'Keyboard Shortcuts', url: 'https://raw.githubusercontent.com/CodyGantCivic/toolkit-data/main/scripts/on-load/keyboard-shortcuts.js', pages: ['/admin*'] },
    { id: 'title_changer', name: 'Title Changer', url: 'https://raw.githubusercontent.com/CodyGantCivic/toolkit-data/main/scripts/on-load/title-changer.js', pages: ['/admin*','/designcenter*'] },

    // 5) Helpers to run last on all pages: auto-dismiss and session timeout prevention
    { id: 'auto_dismiss_help_welcome', name: 'Auto Dismiss Help Welcome', url: 'https://raw.githubusercontent.com/CodyGantCivic/toolkit-data/main/scripts/on-load/auto-dismiss-help-welcome.js', pages: ['*'] },
    { id: 'prevent_session_timeout', name: 'Prevent Session Timeout', url: 'https://raw.githubusercontent.com/CodyGantCivic/toolkit-data/main/scripts/on-load/PreventSessionTimeout.js', pages: ['/admin*','/designcenter*'] }
  ];

  // On-demand registry: tools that run only when the user explicitly clicks on them
  // These helpers are not injected automatically on page load. Each entry should
  // specify a unique id, a human-friendly name, and the raw GitHub URL for the script.
  const onDemandRegistry = [
    {
      id: 'copy_comprehensive',
      name: 'Copy Comprehensive Script',
      url: 'https://raw.githubusercontent.com/CodyGantCivic/toolkit-data/main/scripts/on%20demand/copyComprehensive.js'
    }
    // Add additional on-demand tools here by listing their id, name, and GitHub raw URL.
  ];
  // ======================================================
  // Run an on-demand tool: fetch the script from GitHub and inject it.
  async function runOnDemand(entry) {
    try {
      // Prevent multiple injections of the same tool
      if (window.CPToolkit && window.CPToolkit.injectedScripts && window.CPToolkit.injectedScripts[entry.id]) {
        return;
      }
      const resp = await fetch(entry.url, { cache: 'no-store' });
      if (!resp.ok) throw new Error('fetch failed ' + resp.status);
      const code = await resp.text();
      const el = document.createElement('script');
      el.type = 'text/javascript';
      el.setAttribute('data-cp-on-demand-id', entry.id);
      el.textContent = code + '\n//# sourceURL=' + entry.url + '\n';
      (document.head || document.documentElement).appendChild(el);
      window.CPToolkit.injectedScripts = window.CPToolkit.injectedScripts || {};
      window.CPToolkit.injectedScripts[entry.id] = true;
    } catch (e) {
      console.error(TOOL_NAME + ' on-demand run failed for ' + entry.name, e);
    }
  }

  if (window.top !== window.self) return;

  window.CPToolkit = window.CPToolkit || {};
  if (window.CPToolkit._managerInstalled) return;
  window.CPToolkit._managerInstalled = true;

  // --- pageMatches helper (exact if no *) ---
  function pageMatches(patterns) {
    try {
      const pathname = (window.location.pathname || '').toLowerCase();
      return patterns.some(function (p) {
        const pat = String(p || '').toLowerCase();
        if (!pat) return false;
        if (pat.indexOf('*') >= 0) {
          const re = new RegExp('^' + pat.replace(/\*/g, '.*') + '$');
          return re.test(pathname);
        }
        if (pathname === pat) return true;
        if (pathname === (pat + '/')) return true;
        if (pat.endsWith('/') && pathname === pat.slice(0, -1)) return true;
        return false;
      });
    } catch (e) {
      return false;
    }
  }

  // storage
  function readEnabledMap() {
    try { const raw = localStorage.getItem(STORAGE_KEY); return raw ? JSON.parse(raw) : null; } catch (e) { return null; }
  }
  function writeEnabledMap(map) {
    try { localStorage.setItem(STORAGE_KEY, JSON.stringify(map)); return true; } catch (e) { console.error(TOOL_NAME + ' failed saving settings', e); return false; }
  }
  function effectiveEnabledMap() {
    const stored = readEnabledMap();
    if (!stored) { const allOn = {}; scriptRegistry.forEach(s => allOn[s.id] = true); return allOn; }
    scriptRegistry.forEach(s => { if (stored[s.id] === undefined) stored[s.id] = true; });
    return stored;
  }

  // Minimal manager UI (keeps previous behavior)
  function createManagerUI() {
    if (document.getElementById('cptoolkit-manager-root')) return;
    const root = document.createElement('div');
    root.id = 'cptoolkit-manager-root';
    root.innerHTML = `
      <style>
        #cptoolkit-fab {
          position: fixed;
          right: -60px;
          top: 20px;
          /* Position at top right instead of centered vertically */
          transform: none;
          width: 48px;
          height: 48px;
          border-radius: 50%;
          background: url('https://raw.githubusercontent.com/CodyGantCivic/toolkit-data/main/images/civicplus-circle.jpg') no-repeat center/cover;
          background-size: cover;
          box-shadow: 0 6px 18px rgba(0, 0, 0, 0.25);
          cursor: pointer;
          z-index: 2147483000;
          transition: right 240ms cubic-bezier(.2,.9,.2,1), opacity 160ms;
          opacity: 0.95;
          user-select: none;
        }
        #cptoolkit-fab .tab,
        #cptoolkit-fab .label {
          display: none;
        }
        #cptoolkit-modal {
          display: none;
          position: fixed;
          right: 20px;
          /* Position the modal directly beneath the icon */
          top: 80px;
          width: 420px;
          max-height: 70vh;
          overflow: auto;
          background: #fff;
          border-radius: 10px;
          box-shadow: 0 12px 30px rgba(4,12,20,0.3);
          z-index: 2147483001;
          padding: 12px;
          font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
        }
        #cptoolkit-modal h3 { margin:0 0 8px 0; font-size:14px;}
        .cptoolkit-entry { display:flex; align-items:center; justify-content:space-between; padding:8px 6px; border-bottom: 1px solid #eef2ff;}
        .cptoolkit-entry .left { display:flex; gap:8px; align-items:center; }
        .cptoolkit-entry .meta { font-size:12px; color:#444; }
        .cptoolkit-controls { display:flex; gap:6px; margin-top:8px; }
        .cptoolkit-btn { padding:6px 10px; border-radius:6px; cursor:pointer; background:#f3f4f6; border:1px solid #e5e7eb; font-size:13px; }
        /* Use CivicPlus red accent color instead of blue */
        .cptoolkit-btn.primary { background:#CC0020; color:#fff; border-color:transparent; }
        .cptoolkit-link { font-size:12px; color:#CC0020; text-decoration: none; margin-left:6px; }
      </style>

      <div id="cptoolkit-fab" title="CP Toolkit" tabindex="0" role="button" aria-label="Open CP Toolkit">
        <div class="tab" aria-hidden="true"></div>
        <div class="label">CP</div>
      </div>

      <div id="cptoolkit-modal" role="dialog" aria-label="CP Toolkit manager">
        <!-- On-demand tools section first -->
        <h3>On-demand Tools</h3>
        <div id="cptoolkit-ondemand-list"></div>
        <!-- Collapsible on-load section. Clicking the heading toggles visibility -->
        <h3 id="cptoolkit-onload-toggle" style="margin-top:14px; cursor:pointer; display:flex; align-items:center; gap:6px;">On-load Scripts <span id="cptoolkit-onload-caret">►</span></h3>
        <div id="cptoolkit-onload-section" style="display:none;">
          <div id="cptoolkit-list"></div>
          <div class="cptoolkit-controls">
            <button id="cptoolkit-enable-all" class="cptoolkit-btn">Enable all</button>
            <button id="cptoolkit-disable-all" class="cptoolkit-btn">Disable all</button>
          </div>
        </div>
      </div>
    `;
    document.documentElement.appendChild(root);

    const fab = document.getElementById('cptoolkit-fab');
    const modal = document.getElementById('cptoolkit-modal');
    const list = document.getElementById('cptoolkit-list');
    const map = effectiveEnabledMap();

    function renderList() {
      list.innerHTML = '';
      scriptRegistry.forEach(s => {
        const entry = document.createElement('div');
        entry.className = 'cptoolkit-entry';
        const left = document.createElement('div'); left.className = 'left';
        const cb = document.createElement('input');
        cb.type = 'checkbox';
        cb.id = 'cptoolkit-cb-' + s.id;
        cb.checked = !!map[s.id];
        // Persist changes immediately when toggled; no need for a separate save button
        cb.addEventListener('change', () => {
          map[s.id] = cb.checked;
          writeEnabledMap(map);
        });
        const title = document.createElement('div');
        // Avoid backtick template literals to prevent truncation in embedding; use string concatenation
        title.innerHTML = '<div><strong>' + s.name + '</strong></div><div class="meta">' + s.pages.join(', ') + '</div>';
        left.appendChild(cb); left.appendChild(title);
        const right = document.createElement('div'); right.style.display='flex'; right.style.alignItems='center'; right.style.gap='6px';
        const openLink = document.createElement('a'); openLink.href = s.url; openLink.target = '_blank'; openLink.className = 'cptoolkit-link'; openLink.textContent = 'Open';
        right.appendChild(openLink);
        entry.appendChild(left); entry.appendChild(right); list.appendChild(entry);
      });
    }
    renderList();

    // Render the list of on-demand tools. These tools are not enabled/disabled; each row
    // shows a run button that fetches and executes the script on demand.
    function renderOnDemandList() {
      const ond = document.getElementById('cptoolkit-ondemand-list');
      if (!ond) return;
      ond.innerHTML = '';
      onDemandRegistry.forEach(entry => {
        const row = document.createElement('div');
        row.className = 'cptoolkit-entry';
        const left = document.createElement('div');
        left.className = 'left';
        // On-demand entries only need a name; no page patterns
        const title = document.createElement('div');
        title.innerHTML = '<strong>' + entry.name + '</strong>';
        left.appendChild(title);
        const right = document.createElement('div');
        right.style.display = 'flex';
        right.style.alignItems = 'center';
        right.style.gap = '6px';
        const runBtn = document.createElement('button');
        runBtn.className = 'cptoolkit-btn primary';
        runBtn.textContent = 'Run';
        runBtn.addEventListener('click', () => {
          runOnDemand(entry);
        });
        right.appendChild(runBtn);
        row.appendChild(left);
        row.appendChild(right);
        ond.appendChild(row);
      });
    }
    // After rendering the on-load list, render the on-demand list
    renderOnDemandList();

    // Set up toggle behavior for the on-load scripts section. When the user clicks
    // the heading, show or hide the on-load list and update the caret. The
    // caret uses ► for collapsed and ▼ for expanded states. By default the
    // section is collapsed (display: none) and the caret shows ►.
    const onloadToggle = document.getElementById('cptoolkit-onload-toggle');
    const onloadSection = document.getElementById('cptoolkit-onload-section');
    const onloadCaret = document.getElementById('cptoolkit-onload-caret');
    let onLoadExpanded = false;
    if (onloadToggle && onloadSection && onloadCaret) {
      onloadToggle.addEventListener('click', () => {
        onLoadExpanded = !onLoadExpanded;
        if (onLoadExpanded) {
          onloadSection.style.display = 'block';
          onloadCaret.textContent = '▼';
        } else {
          onloadSection.style.display = 'none';
          onloadCaret.textContent = '►';
        }
      });
    }

    // Track whether the manager panel is open. When open, the FAB remains visible.
    let visible = false, hideTimer = null, managerOpen = false;
    function show() {
      if (visible) return;
      visible = true;
      fab.style.right = '8px';
    }
    // Hide the FAB only if the manager is not open. Matches the CSS offset (right: -60px).
    function hide() {
      if (!visible || managerOpen) return;
      visible = false;
      fab.style.right = '-60px';
    }
    // Show the FAB when the mouse is near the top-right corner or over the button;
    // hide it when the mouse moves away and the manager is closed.
    document.addEventListener('mousemove', function (e) {
      const dx = window.innerWidth - e.clientX;
      const nearRight = dx <= 24;
      const nearTop = e.clientY <= 120;
      if (nearRight && nearTop) {
        if (hideTimer) { clearTimeout(hideTimer); hideTimer = null; }
        show();
        return;
      }
      const rect = fab.getBoundingClientRect();
      const over = e.clientX >= rect.left && e.clientX <= rect.right &&
                   e.clientY >= rect.top && e.clientY <= rect.bottom;
      if (over) {
        if (hideTimer) { clearTimeout(hideTimer); hideTimer = null; }
        show();
        return;
      }
      if (visible && !hideTimer) {
        hideTimer = setTimeout(() => {
          hide();
          hideTimer = null;
        }, 700);
      }
    }, { passive: true });

    // Clicking the FAB toggles the manager panel. When opened, the FAB stays out.
    fab.addEventListener('click', () => {
      // Cancel any pending hide timers
      if (hideTimer) {
        clearTimeout(hideTimer);
        hideTimer = null;
      }
      managerOpen = !managerOpen;
      if (managerOpen) {
        modal.style.display = 'block';
        show();
      } else {
        modal.style.display = 'none';
        // After closing, slide the FAB back in
        hide();
      }
    });
    // Enable/Disable all buttons still function as before.
    document.getElementById('cptoolkit-enable-all').addEventListener('click', () => {
      scriptRegistry.forEach(s => map[s.id] = true);
      renderList();
    });
    document.getElementById('cptoolkit-disable-all').addEventListener('click', () => {
      scriptRegistry.forEach(s => map[s.id] = false);
      renderList();
    });
  }

  // Only show the manager UI on CivicPlus sites. Wrap UI creation in a helper.
  async function maybeCreateManagerUI() {
    try {
      const isCP = await isCivicPlusSite();
      if (isCP) {
        createManagerUI();
      }
    } catch (e) {
      // ignore detection errors and don't show the UI
    }
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', maybeCreateManagerUI);
  } else {
    setTimeout(maybeCreateManagerUI, 0);
  }

  // CivicPlus detection
  async function isCivicPlusSite() {
    // If detection has already completed, return the cached result to avoid
    // additional network requests. The loader sets window.CPToolkit and
    // caches the detection result on the property `isCivicPlusSiteResult`.
    if (window.CPToolkit && typeof window.CPToolkit.isCivicPlusSiteResult !== 'undefined') {
      return window.CPToolkit.isCivicPlusSiteResult;
    }
    try {
      const testUrl = `${window.location.origin}/Assets/Mystique/Shared/Components/ModuleTiles/Templates/cp-Module-Tile.html`;
      const res = await fetch(testUrl, { method: 'HEAD', cache: 'no-store' }).catch(()=>null);
      if (res && (res.ok || res.type === 'opaque')) {
        // Cache the detection result on CPToolkit so subsequent calls can reuse it
        if (window.CPToolkit) window.CPToolkit.isCivicPlusSiteResult = true;
        return true;
      }
      if (res && res.status === 405) {
        const r2 = await fetch(testUrl, { method: 'GET', cache: 'no-store' }).catch(()=>null);
        if (r2 && (r2.ok || r2.type === 'opaque')) {
          if (window.CPToolkit) window.CPToolkit.isCivicPlusSiteResult = true;
          return true;
        }
      }
      // If none of the detection methods succeeded, cache a false result
      if (window.CPToolkit) window.CPToolkit.isCivicPlusSiteResult = false;
      return false;
    } catch (e) {
      // On error, log and cache a false result to avoid repeated network calls
      console.error(TOOL_NAME + ' detection error', e);
      if (window.CPToolkit) window.CPToolkit.isCivicPlusSiteResult = false;
      return false;
    }
  }

  async function fetchAndInject(scriptEntry) {
    try {
      const r = await fetch(scriptEntry.url, { cache: 'no-store' });
      if (!r.ok) throw new Error('fetch failed ' + r.status);
      const txt = await r.text();
      if (!txt) throw new Error('empty script');
      const el = document.createElement('script');
      el.type = 'text/javascript';
      el.setAttribute('data-cp-script-id', scriptEntry.id);
      el.textContent = txt + `\n//# sourceURL=${scriptEntry.url}\n`;
      (document.head || document.documentElement).appendChild(el);
      window.CPToolkit.injectedScripts = window.CPToolkit.injectedScripts || {};
      window.CPToolkit.injectedScripts[scriptEntry.id] = true;
      return true;
    } catch (err) {
      console.error(TOOL_NAME + ' inject error for ' + scriptEntry.name, err);
      return false;
    }
  }

  function waitForGlobal(name, timeout = 2000, interval = 60) {
    return new Promise((resolve) => {
      const start = Date.now();
      (function check() {
        const parts = name.split('.');
        let cur = window;
        for (const p of parts) { if (!cur) break; cur = cur[p]; }
        if (cur) return resolve(cur);
        if (Date.now() - start > timeout) return resolve(null);
        setTimeout(check, interval);
      })();
    });
  }

  async function maybeInjectAndRun(entry, enabledMap) {
    try {
      if (!enabledMap[entry.id]) return false;
      if (Array.isArray(entry.pages) && entry.pages.length) {
        if (!pageMatches(entry.pages)) return false;
      }
      if (!(window.CPToolkit.injectedScripts && window.CPToolkit.injectedScripts[entry.id])) {
        console.log('Activating ' + entry.name);
        const ok = await fetchAndInject(entry);
        if (!ok) return false;
      }

      // special-case known globals
      if (entry.id === 'xml_major_change_alert') {
        const g = await waitForGlobal('XMLMajorChangeAlert', 2500);
        if (g && typeof g.init === 'function') {
          try { g.init(); } catch (e) { console.error(TOOL_NAME + ' error calling init for ' + entry.name, e); }
        }
        return true;
      }

      if (entry.id === 'allow_open_in_new_tab') {
        const g = await waitForGlobal('AllowOpenInNewTab', 1500);
        if (g && typeof g.init === 'function') {
          try { g.init(); } catch (e) { console.error(TOOL_NAME + ' error calling init for ' + entry.name, e); }
        }
        return true;
      }

      // DownloadXMLCSS helper exports `window.DownloadXMLCSS`. Without this special case,
      // the loader candidates would not match because the name contains slashes in the entry name.
      if (entry.id === 'download_xml_css') {
        const g = await waitForGlobal('DownloadXMLCSS', 2000);
        if (g && typeof g.init === 'function') {
          try { g.init(); } catch (e) { console.error(TOOL_NAME + ' error calling init for ' + entry.name, e); }
        }
        return true;
      }

      const candidates = [entry.id, entry.name.replace(/\s+/g, '_'), entry.name.replace(/\s+/g, '')];
      for (const c of candidates) {
        const glob = await waitForGlobal(c, 1200);
        if (glob) {
          try {
            if (typeof glob.init === 'function') glob.init();
            else if (typeof glob === 'function') glob();
          } catch (e) { console.error(TOOL_NAME + ' error calling init for ' + entry.name, e); }
          break;
        }
      }
      return true;
    } catch (err) {
      console.error(TOOL_NAME + ' maybeInjectAndRun error for ' + entry.name, err);
      return false;
    }
  }

  async function mainFlow() {
    try {
      const isCP = await isCivicPlusSite();
      if (!isCP) return;
      const enabledMap = effectiveEnabledMap();
      for (const s of scriptRegistry) {
        await maybeInjectAndRun(s, enabledMap);
      }
    } catch (e) {
      console.error(TOOL_NAME + ' mainFlow error', e);
    }
  }

  (function initialRunner() {
    try {
      mainFlow().catch(() => {});
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', mainFlow);
      } else {
        setTimeout(mainFlow, 150);
      }
    } catch (e) {
      console.error(TOOL_NAME + ' initialRunner error', e);
    }
  })();

  (function setupSpa() {
    try {
      let timer = null;
      function notify() {
        if (timer) clearTimeout(timer);
        timer = setTimeout(() => { mainFlow().catch(()=>{}); }, 200);
      }
      const _push = history.pushState;
      const _replace = history.replaceState;
      history.pushState = function () { const res = _push.apply(this, arguments); notify(); return res; };
      history.replaceState = function () { const res = _replace.apply(this, arguments); notify(); return res; };
      window.addEventListener('popstate', notify);
      window.addEventListener('focus', () => mainFlow().catch(()=>{}));
      document.addEventListener('visibilitychange', () => { if (document.visibilityState === 'visible') mainFlow().catch(()=>{}); });
    } catch (e) {
      console.error(TOOL_NAME + ' SPA watcher error', e);
    }
  })();

})();
